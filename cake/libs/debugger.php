<?php
/**
 * Framework debugging and PHP error-handling class.
 *
 * Provides enhanced logging, stack traces, and rendering debug views
 *
 * PHP versions 4 and 5
 *
 * CakePHP(tm) : Rapid Development Framework (http://cakephp.org)
 * Copyright 2005-2012, Cake Software Foundation, Inc. (http://cakefoundation.org)
 *
 * Licensed under The MIT License
 * Redistributions of files must retain the above copyright notice.
 *
 * @copyright     Copyright 2005-2012, Cake Software Foundation, Inc. (http://cakefoundation.org)
 *
 * @see          http://cakephp.org CakePHP(tm) Project
 * @since         CakePHP(tm) v 1.2.4560
 *
 * @license       MIT License (http://www.opensource.org/licenses/mit-license.php)
 */

/**
 * Included libraries.
 */
if (!class_exists('Object')) {
    require_once LIBS.'object.php';
}
if (!class_exists('CakeLog')) {
    require_once LIBS.'cake_log.php';
}
if (!class_exists('String')) {
    require_once LIBS.'string.php';
}

/**
 * Provide custom logging and error handling.
 *
 * Debugger overrides PHP's default error handling to provide stack traces and enhanced logging
 *
 * @see          http://book.cakephp.org/1.3/en/The-Manual/Common-Tasks-With-CakePHP/Debugging.html#Using-the-Debugger-Class
 */
class Debugger extends Object
{
    /**
     * A list of errors generated by the application.
     *
     * @var array
     */
    public $errors = [];

    /**
     * Contains the base URL for error code documentation.
     *
     * @var string
     */
    public $helpPath = null;

    /**
     * The current output format.
     *
     * @var string
     */
    public $_outputFormat = 'js';

    /**
     * Templates used when generating trace or error strings.  Can be global or indexed by the format
     * value used in $_outputFormat.
     *
     * @var string
     */
    public $_templates = [
        'log' => [
            'trace' => '{:reference} - {:path}, line {:line}',
            'error' => '{:error} ({:code}): {:description} in [{:file}, line {:line}]',
        ],
        'js' => [
            'error' => '',
            'info' => '',
            'trace' => '<pre class="stack-trace">{:trace}</pre>',
            'code' => '',
            'context' => '',
            'links' => [],
        ],
        'html' => [
            'trace' => '<pre class="cake-debug trace"><b>Trace</b> <p>{:trace}</p></pre>',
            'context' => '<pre class="cake-debug context"><b>Context</b> <p>{:context}</p></pre>',
        ],
        'txt' => [
            'error' => "{:error}: {:code} :: {:description} on line {:line} of {:path}\n{:info}",
            'context' => "Context:\n{:context}\n",
            'trace' => "Trace:\n{:trace}\n",
            'code' => '',
            'info' => '',
        ],
        'base' => [
            'traceLine' => '{:reference} - {:path}, line {:line}',
        ],
    ];

    /**
     * Holds current output data when outputFormat is false.
     *
     * @var string
     */
    public $_data = [];

    /**
     * Constructor.
     */
    public function __construct()
    {
        $docRef = ini_get('docref_root');

        if (empty($docRef) && function_exists('ini_set')) {
            ini_set('docref_root', 'http://php.net/');
        }
        if (!defined('E_RECOVERABLE_ERROR')) {
            define('E_RECOVERABLE_ERROR', 4096);
        }
        if (!defined('E_DEPRECATED')) {
            define('E_DEPRECATED', 8192);
        }

        $e = '<pre class="cake-debug">';
        $e .= '<a href="javascript:void(0);" onclick="document.getElementById(\'{:id}-trace\')';
        $e .= '.style.display = (document.getElementById(\'{:id}-trace\').style.display == ';
        $e .= '\'none\' ? \'\' : \'none\');"><b>{:error}</b> ({:code})</a>: {:description} ';
        $e .= '[<b>{:path}</b>, line <b>{:line}</b>]';

        $e .= '<div id="{:id}-trace" class="cake-stack-trace" style="display: none;">';
        $e .= '{:links}{:info}</div>';
        $e .= '</pre>';
        $this->_templates['js']['error'] = $e;

        $t = '<div id="{:id}-trace" class="cake-stack-trace" style="display: none;">';
        $t .= '{:context}{:code}{:trace}</div>';
        $this->_templates['js']['info'] = $t;

        $links = [];
        $link = '<a href="javascript:void(0);" onclick="document.getElementById(\'{:id}-code\')';
        $link .= '.style.display = (document.getElementById(\'{:id}-code\').style.display == ';
        $link .= '\'none\' ? \'\' : \'none\')">Code</a>';
        $links['code'] = $link;

        $link = '<a href="javascript:void(0);" onclick="document.getElementById(\'{:id}-context\')';
        $link .= '.style.display = (document.getElementById(\'{:id}-context\').style.display == ';
        $link .= '\'none\' ? \'\' : \'none\')">Context</a>';
        $links['context'] = $link;

        $links['help'] = '<a href="{:helpPath}{:code}" target="_blank">Help</a>';
        $this->_templates['js']['links'] = $links;

        $this->_templates['js']['context'] = '<pre id="{:id}-context" class="cake-context" ';
        $this->_templates['js']['context'] .= 'style="display: none;">{:context}</pre>';

        $this->_templates['js']['code'] = '<div id="{:id}-code" class="cake-code-dump" ';
        $this->_templates['js']['code'] .= 'style="display: none;"><pre>{:code}</pre></div>';

        $e = '<pre class="cake-debug"><b>{:error}</b> ({:code}) : {:description} ';
        $e .= '[<b>{:path}</b>, line <b>{:line}]</b></pre>';
        $this->_templates['html']['error'] = $e;

        $this->_templates['html']['context'] = '<pre class="cake-debug context"><b>Context</b> ';
        $this->_templates['html']['context'] .= '<p>{:context}</p></pre>';
    }

    /**
     * Returns a reference to the Debugger singleton object instance.
     *
     * @return object
     * @static
     */
    public function &getInstance($class = null)
    {
        static $instance = [];
        if (!empty($class)) {
            if (!$instance || strtolower($class) != strtolower(get_class($instance[0]))) {
                $instance[0] = new $class();
                if (Configure::read() > 0) {
                    Configure::version(); // Make sure the core config is loaded
                    $instance[0]->helpPath = Configure::read('Cake.Debugger.HelpPath');
                }
            }
        }

        if (!$instance) {
            $instance[0] = new self();
            if (Configure::read() > 0) {
                Configure::version(); // Make sure the core config is loaded
                $instance[0]->helpPath = Configure::read('Cake.Debugger.HelpPath');
            }
        }

        return $instance[0];
    }

    /**
     * Formats and outputs the contents of the supplied variable.
     *
     * @param $var mixed the variable to dump
     *
     * @see Debugger::exportVar()
     * @static
     *
     * @see http://book.cakephp.org/1.3/en/The-Manual/Common-Tasks-With-CakePHP/Debugging.html#Using-the-Debugger-Class
     */
    public function dump($var)
    {
        $_this = &self::getInstance();
        pr($_this->exportVar($var));
    }

    /**
     * Creates an entry in the log file.  The log entry will contain a stack trace from where it was called.
     * as well as export the variable using exportVar. By default the log is written to the debug log.
     *
     * @param $var mixed Variable or content to log
     * @param $level int type of log to use. Defaults to LOG_DEBUG
     * @static
     *
     * @see http://book.cakephp.org/1.3/en/The-Manual/Common-Tasks-With-CakePHP/Debugging.html#Using-the-Debugger-Class
     */
    public function log($var, $level = LOG_DEBUG)
    {
        $_this = &self::getInstance();
        $source = $_this->trace(['start' => 1])."\n";
        CakeLog::write($level, "\n".$source.$_this->exportVar($var));
    }

    /**
     * Overrides PHP's default error handling.
     *
     * @param int    $code        Code of error
     * @param string $description Error description
     * @param string $file        File on which error occurred
     * @param int    $line        Line that triggered the error
     * @param array  $context     Context
     *
     * @return bool true if error was handled
     */
    public function handleError($code, $description, $file = null, $line = null, $context = null)
    {
        if (0 == error_reporting() || 2048 === $code || 8192 === $code) {
            return;
        }

        $_this = &self::getInstance();

        if (empty($file)) {
            $file = '[internal]';
        }
        if (empty($line)) {
            $line = '??';
        }
        $path = $_this->trimPath($file);

        $info = compact('code', 'description', 'file', 'line');
        if (!in_array($info, $_this->errors)) {
            $_this->errors[] = $info;
        } else {
            return;
        }

        switch ($code) {
            case E_PARSE:
            case E_ERROR:
            case E_CORE_ERROR:
            case E_COMPILE_ERROR:
            case E_USER_ERROR:
                $error = 'Fatal Error';
                $level = LOG_ERROR;
            break;
            case E_WARNING:
            case E_USER_WARNING:
            case E_COMPILE_WARNING:
            case E_RECOVERABLE_ERROR:
                $error = 'Warning';
                $level = LOG_WARNING;
            break;
            case E_NOTICE:
            case E_USER_NOTICE:
                $error = 'Notice';
                $level = LOG_NOTICE;
            break;
            default:
                return;
            break;
        }

        $helpCode = null;
        if (!empty($_this->helpPath) && preg_match('/.*\[([0-9]+)\]$/', $description, $codes)) {
            if (isset($codes[1])) {
                $helpID = $codes[1];
                $description = trim(preg_replace('/\[[0-9]+\]$/', '', $description));
            }
        }

        $data = compact(
            'level', 'error', 'code', 'helpID', 'description', 'file', 'path', 'line', 'context'
        );
        echo $_this->_output($data);

        if (Configure::read('log')) {
            $tpl = $_this->_templates['log']['error'];
            $options = ['before' => '{:', 'after' => '}'];
            CakeLog::write($level, String::insert($tpl, $data, $options));
        }

        if ('Fatal Error' == $error) {
            exit();
        }

        return true;
    }

    /**
     * Outputs a stack trace based on the supplied options.
     *
     * ### Options
     *
     * - `depth` - The number of stack frames to return. Defaults to 999
     * - `format` - The format you want the return.  Defaults to the currently selected format.  If
     *    format is 'array' or 'points' the return will be an array.
     * - `args` - Should arguments for functions be shown?  If true, the arguments for each method call
     *   will be displayed.
     * - `start` - The stack frame to start generating a trace from.  Defaults to 0
     *
     * @param array $options Format for outputting stack trace
     *
     * @return mixed Formatted stack trace
     * @static
     *
     * @see http://book.cakephp.org/1.3/en/The-Manual/Common-Tasks-With-CakePHP/Debugging.html#Using-the-Debugger-Class
     */
    public function trace($options = [])
    {
        $_this = &self::getInstance();
        $defaults = [
            'depth' => 999,
            'format' => $_this->_outputFormat,
            'args' => false,
            'start' => 0,
            'scope' => null,
            'exclude' => null,
        ];
        $options += $defaults;

        $backtrace = debug_backtrace();
        $count = count($backtrace);
        $back = [];

        $_trace = [
            'line' => '??',
            'file' => '[internal]',
            'class' => null,
            'function' => '[main]',
        ];

        for ($i = $options['start']; $i < $count && $i < $options['depth']; ++$i) {
            $trace = array_merge(['file' => '[internal]', 'line' => '??'], $backtrace[$i]);

            if (isset($backtrace[$i + 1])) {
                $next = array_merge($_trace, $backtrace[$i + 1]);
                $reference = $next['function'];

                if (!empty($next['class'])) {
                    $reference = $next['class'].'::'.$reference.'(';
                    if ($options['args'] && isset($next['args'])) {
                        $args = [];
                        foreach ($next['args'] as $arg) {
                            $args[] = self::exportVar($arg);
                        }
                        $reference .= join(', ', $args);
                    }
                    $reference .= ')';
                }
            } else {
                $reference = '[main]';
            }
            if (in_array($reference, ['call_user_func_array', 'trigger_error'])) {
                continue;
            }
            if ('points' == $options['format'] && '[internal]' != $trace['file']) {
                $back[] = ['file' => $trace['file'], 'line' => $trace['line']];
            } elseif ('array' == $options['format']) {
                $back[] = $trace;
            } else {
                if (isset($_this->_templates[$options['format']]['traceLine'])) {
                    $tpl = $_this->_templates[$options['format']]['traceLine'];
                } else {
                    $tpl = $_this->_templates['base']['traceLine'];
                }
                $trace['path'] = self::trimPath($trace['file']);
                $trace['reference'] = $reference;
                unset($trace['object'], $trace['args']);
                $back[] = String::insert($tpl, $trace, ['before' => '{:', 'after' => '}']);
            }
        }

        if ('array' == $options['format'] || 'points' == $options['format']) {
            return $back;
        }

        return implode("\n", $back);
    }

    /**
     * Shortens file paths by replacing the application base path with 'APP', and the CakePHP core
     * path with 'CORE'.
     *
     * @param string $path Path to shorten
     *
     * @return string Normalized path
     * @static
     */
    public function trimPath($path)
    {
        if (!defined('CAKE_CORE_INCLUDE_PATH') || !defined('APP')) {
            return $path;
        }

        if (0 === strpos($path, APP)) {
            return str_replace(APP, 'APP'.DS, $path);
        } elseif (0 === strpos($path, CAKE_CORE_INCLUDE_PATH)) {
            return str_replace(CAKE_CORE_INCLUDE_PATH, 'CORE', $path);
        } elseif (0 === strpos($path, ROOT)) {
            return str_replace(ROOT, 'ROOT', $path);
        }
        $corePaths = App::core('cake');

        foreach ($corePaths as $corePath) {
            if (0 === strpos($path, $corePath)) {
                return str_replace($corePath, 'CORE'.DS.'cake'.DS, $path);
            }
        }

        return $path;
    }

    /**
     * Grabs an excerpt from a file and highlights a given line of code.
     *
     * @param string $file    Absolute path to a PHP file
     * @param int    $line    Line number to highlight
     * @param int    $context Number of lines of context to extract above and below $line
     *
     * @return array Set of lines highlighted
     * @static
     *
     * @see http://book.cakephp.org/1.3/en/The-Manual/Common-Tasks-With-CakePHP/Debugging.html#Using-the-Debugger-Class
     */
    public function excerpt($file, $line, $context = 2)
    {
        $data = $lines = [];
        if (!file_exists($file)) {
            return [];
        }
        $data = @explode("\n", file_get_contents($file));

        if (empty($data) || !isset($data[$line])) {
            return;
        }
        for ($i = $line - ($context + 1); $i < $line + $context; ++$i) {
            if (!isset($data[$i])) {
                continue;
            }
            $string = str_replace(["\r\n", "\n"], '', highlight_string($data[$i], true));
            if ($i == $line) {
                $lines[] = '<span class="code-highlight">'.$string.'</span>';
            } else {
                $lines[] = $string;
            }
        }

        return $lines;
    }

    /**
     * Converts a variable to a string for debug output.
     *
     * @param string $var Variable to convert
     *
     * @return string Variable as a formatted string
     * @static
     *
     * @see http://book.cakephp.org/1.3/en/The-Manual/Common-Tasks-With-CakePHP/Debugging.html#Using-the-Debugger-Class
     */
    public function exportVar($var, $recursion = 0)
    {
        $_this = &self::getInstance();
        switch (strtolower(gettype($var))) {
            case 'boolean':
                return ($var) ? 'true' : 'false';
            break;
            case 'integer':
            case 'double':
                return $var;
            break;
            case 'string':
                if ('' == trim($var)) {
                    return '""';
                }

                return '"'.h($var).'"';
            break;
            case 'object':
                return get_class($var)."\n".$_this->__object($var);
            case 'array':
                $var = array_merge($var, array_intersect_key([
                    'password' => '*****',
                    'login' => '*****',
                    'host' => '*****',
                    'database' => '*****',
                    'port' => '*****',
                    'prefix' => '*****',
                    'schema' => '*****',
                ], $var));

                $out = 'array(';
                $vars = [];
                foreach ($var as $key => $val) {
                    if ($recursion >= 0) {
                        if (is_numeric($key)) {
                            $vars[] = "\n\t".$_this->exportVar($val, $recursion - 1);
                        } else {
                            $vars[] = "\n\t".$_this->exportVar($key, $recursion - 1)
                                        .' => '.$_this->exportVar($val, $recursion - 1);
                        }
                    }
                }
                $n = null;
                if (!empty($vars)) {
                    $n = "\n";
                }

                return $out.implode(',', $vars)."{$n})";
            break;
            case 'resource':
                return strtolower(gettype($var));
            break;
            case 'null':
                return 'null';
            break;
        }
    }

    /**
     * Handles object to string conversion.
     *
     * @param string $var Object to convert
     *
     * @return string
     *
     * @see Debugger::exportVar()
     */
    public function __object($var)
    {
        $out = [];

        if (is_object($var)) {
            $className = get_class($var);
            $objectVars = get_object_vars($var);

            foreach ($objectVars as $key => $value) {
                if (is_object($value)) {
                    $value = get_class($value).' object';
                } elseif (is_array($value)) {
                    $value = 'array';
                } elseif (null === $value) {
                    $value = 'NULL';
                } elseif (in_array(gettype($value), ['boolean', 'integer', 'double', 'string', 'array', 'resource'])) {
                    $value = self::exportVar($value);
                }
                $out[] = "$className::$$key = ".$value;
            }
        }

        return implode("\n", $out);
    }

    /**
     * Switches output format, updates format strings.
     *
     * @param string $format  format to use, including 'js' for JavaScript-enhanced HTML, 'html' for
     *                        straight HTML output, or 'txt' for unformatted text
     * @param array  $strings template strings to be used for the output format
     */
    public function output($format = null, $strings = [])
    {
        $_this = &self::getInstance();
        $data = null;

        if (is_null($format)) {
            return $_this->_outputFormat;
        }

        if (!empty($strings)) {
            if (isset($_this->_templates[$format])) {
                if (isset($strings['links'])) {
                    $_this->_templates[$format]['links'] = array_merge(
                        $_this->_templates[$format]['links'],
                        $strings['links']
                    );
                    unset($strings['links']);
                }
                $_this->_templates[$format] = array_merge($_this->_templates[$format], $strings);
            } else {
                $_this->_templates[$format] = $strings;
            }

            return $_this->_templates[$format];
        }

        if (true === $format && !empty($_this->_data)) {
            $data = $_this->_data;
            $_this->_data = [];
            $format = false;
        }
        $_this->_outputFormat = $format;

        return $data;
    }

    /**
     * Renders error messages.
     *
     * @param array $data Data about the current error
     */
    public function _output($data = [])
    {
        $defaults = [
            'level' => 0,
            'error' => 0,
            'code' => 0,
            'helpID' => null,
            'description' => '',
            'file' => '',
            'line' => 0,
            'context' => [],
        ];
        $data += $defaults;

        $files = $this->trace(['start' => 2, 'format' => 'points']);
        $code = '';
        if (isset($files[1]['file'])) {
            $code = $this->excerpt($files[1]['file'], $files[1]['line'] - 1, 1);
        }
        $trace = $this->trace(['start' => 2, 'depth' => '20']);
        $insertOpts = ['before' => '{:', 'after' => '}'];
        $context = [];
        $links = [];
        $info = '';

        foreach ((array) $data['context'] as $var => $value) {
            $context[] = "\${$var}\t=\t".$this->exportVar($value, 1);
        }

        switch ($this->_outputFormat) {
            case false:
                $this->_data[] = compact('context', 'trace') + $data;

                return;
            case 'log':
                $this->log(compact('context', 'trace') + $data);

                return;
        }

        if (empty($this->_outputFormat) || !isset($this->_templates[$this->_outputFormat])) {
            $this->_outputFormat = 'js';
        }

        $data['id'] = 'cakeErr'.count($this->errors);
        $tpl = array_merge($this->_templates['base'], $this->_templates[$this->_outputFormat]);
        $insert = ['context' => join("\n", $context), 'helpPath' => $this->helpPath] + $data;

        $detect = ['help' => 'helpID', 'context' => 'context'];

        if (isset($tpl['links'])) {
            foreach ($tpl['links'] as $key => $val) {
                if (isset($detect[$key]) && empty($insert[$detect[$key]])) {
                    continue;
                }
                $links[$key] = String::insert($val, $insert, $insertOpts);
            }
        }

        foreach (['code', 'context', 'trace'] as $key) {
            if (empty($$key) || !isset($tpl[$key])) {
                continue;
            }
            if (is_array($$key)) {
                $$key = join("\n", $$key);
            }
            $info .= String::insert($tpl[$key], compact($key) + $insert, $insertOpts);
        }
        $links = join(' | ', $links);
        unset($data['context']);

        echo String::insert($tpl['error'], compact('links', 'info') + $data, $insertOpts);
    }

    /**
     * Verifies that the application's salt and cipher seed value has been changed from the default value.
     *
     * @static
     */
    public function checkSecurityKeys()
    {
        if ('DYhG93b0qyJfIxfs2guVoUubWwvniR2G0FgaC9mi' == Configure::read('Security.salt')) {
            trigger_error(__('Please change the value of \'Security.salt\' in app/config/core.php to a salt value specific to your application', true), E_USER_NOTICE);
        }

        if ('76859309657453542496749683645' === Configure::read('Security.cipherSeed')) {
            trigger_error(__('Please change the value of \'Security.cipherSeed\' in app/config/core.php to a numeric (digits only) seed value specific to your application', true), E_USER_NOTICE);
        }
    }

    /**
     * Invokes the given debugger object as the current error handler, taking over control from the
     * previous handler in a stack-like hierarchy.
     *
     * @param object $debugger A reference to the Debugger object
     * @static
     *
     * @see http://book.cakephp.org/1.3/en/The-Manual/Common-Tasks-With-CakePHP/Debugging.html#Using-the-Debugger-Class
     */
    public function invoke(&$debugger)
    {
        set_error_handler([&$debugger, 'handleError']);
    }
}

if (!defined('DISABLE_DEFAULT_ERROR_HANDLING')) {
    Debugger::invoke(Debugger::getInstance());
}
